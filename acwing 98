#include<cstring>
#include<iostream>
// acwing  98
//与其有区别的为  我们需要将所给的矩阵的灯变为全黑，也就是全部都是0
//我们对此题的解发为暴力遍历所有的按法
/*
 * 但是不同的是，我们对于暴力，仅仅是暴力第一行的所有按法，因为，对于此题来讲，当第一行的状态确定的时候，后面的按法也随之确定，只需要不断地去使
 * i行的1变为0即可，总有一种情况，在第一行的确定的时候，对后面的行进行不断地改变，到达最后一行的时候，可以使其所有的位置都为0
 * 要注意的使，我们不会去设计一种算法具有独立思考能力，如何去按压每一步骤，对于计算机来说，只能暴力去列出每一种情况，再对其所有的情况进行筛选我们所需要的可行解
 * 不可否认的是，计算机的解决之法是暴力的，美丽的。
 * 对于这么多的解决情况，我们对其进行状态压缩，用一个数组来存贮第一行的情况
 *
 * */
const int N =6;
int a[N],ans,aa[N];
char s[N];
void dj(int x,int y){   //x=1，y =i ，也就是该检查第i位置的01情况
    // 对压缩状态的第y位置的第x行进行操作，理论上讲，y易变，但x不易变，因为需要对图的每一行的每一个位置进行判断

    aa[x] ^= (1<<y);  //x=1.代表为第一行的状态，要将第y位置的状态设置为1， ^ 若有一个为1，则均为1，两者都不为1，则为0，但是我们所或的对象为1，则说明此位置结果必为1
    //对这一行的上下改写，与操作，若为1则为1，若为0，则为1
    if(x!=1) aa[x-1] ^= (1<<y);
    //如果非第一行的位置，则需要将第i-1行调整为i
    if(x!=5) aa[x+1] ^= (1<<y);
   //这是一个疗程的操作，我们需要将地图所有的位置都设置为1，则对于每一行来说，需要将每一行非1的位置设置为1，
    //此操作在计算机里面分为两步来实现，首先将第i行需要操作的位置的值设置为1，再将第i+1行该位置的值设置为1，进而促使了一个疗程的操作
    if(y!=0) aa[x] ^= (1<<(y-1));  //对于这一行左右值改写
    if(y!=4) aa[x] ^= (1<<(y+1));
}
void pd(int p){
    int k =0;
    memcpy(aa,a,sizeof(a));  //cpy函数，将 a数组的数值从a的初始直至结束均赋值给aa，也就是说创建一个aa作为a的临时数组
    //用于存储图的信息
    for(int i=0;i<5;i++)  //对图的第一行进行初始化处理，需要尝试所有的情况
        if(!((p>>1)&1)){  //如果 p的位置不为1，dj的操作为当判断为需要改写时候改写，如果不需要改写的时候是不进入语句块的
        //也就是说如果该位置的的p不为1，则需要进入语句块进行改写
            dj(1,i);
            if(++k>=ans)return ;
        }
    for(int x=1;x<5;x++)  //从第一行开使处理
        for(int y = 0;y< 5;y++)
            if(!((aa[x]>>y)&1)){  //若aa的x位置为0，则进入语句块
                dj(x+1,y);  // 对x+1行进行操作，间接改变x行
                if(++k>=ans)return ;
            }
    if(aa[5]==31) ans =k;  //对最小操作次数的判断
}
void abc(){
    memset(a,0,sizeof(a));

    for(int i=1;i<= 5;i++){  //对图的输入
        std::cin>> (s+1);
        /*
         * a[i] 为图的第i行的状态压缩之后的数，也就是说，5个格子表示了5*5的图
         *  图a使从下标为1开始的
         * */
        for(int j=1;i<=5;i++) a[i]=a[i]*2+(s[j]-'0');  //行处理 每一行的数为 该位置左移一位置，紧接着最低位加上该位置的0 或 1
        //对于移位操作来说，左移1等于 该数乘以2
        //到此位置，一个样例的图的输入已经完成
    }
    ans =7;
    for(int p=0;p<(1<<5);p++) pd(p); //这里，从p=0枚举导p等于1<<5 其中各个位01不等，所有组合均可遍历

    if(ans == 7) std::cout<< "-1" <<std::endl;  //最后 若ans为7，则说明其并没有选择使其改变
    else std::cout<<ans <<std::endl;

}
int main(){
    int n;
    std::cin>>n;  //样例数
    while(n--) abc();  //5个样例
    return 0;
}
